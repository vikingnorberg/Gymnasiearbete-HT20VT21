\documentclass[a4]{article}

% twoside twocolumn

%\usepackage[pdftex]{color, graphicx, epsfig}
%\usepackage[final]{pdfpages}

%\usepackage[print]{booklet}

\usepackage{amsmath}
\usepackage[swedish]{babel}
\usepackage{blindtext}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage[table]{xcolor}
\usepackage{subfiles}
\usepackage{multicol}
\usepackage[bottom]{footmisc}
\usepackage{amsfonts}
\usepackage{pgfplots} 
\usepackage{longdivision}
\usepackage{polynom}
\usepackage[hidelinks]{hyperref}
\usepackage{biblatex}
\usepackage{csquotes}

\pgfplotsset{width=8cm, compat=1.9}
% width=13cm
\addbibresource{../../sources.bib}

\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\definecolor{purple}{rgb}{0.65,0.14,0.64}
\definecolor{lightBlue}{rgb}{0.25,0.47,0.94}
\definecolor{uglyBrown}{rgb}{0,1,0}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    keywordstyle=[2]\color{purple},
    keywordstyle=[3]\color{lightBlue},
    keywordstyle=[4]\color{uglyBrown},
    keywordstyle=[5]\color{codegreen},
    keywords=[2]{
        for, int, if, static, public, void, int
    },
    keywords=[3]{
        swap, bubbleSort, insertionSort, Length, multiplyByTwo
    },
    keywords=[4]{
        1, 2, 3, 4, 5, 6, 7, 8, 9, 0
    },
    keywords=[5]{
        return
    },
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    tabsize=1,
}
\lstset{style=mystyle}

\begin{document}

\onecolumn
\pagestyle{fancy}
\fancyhf{}
\rhead{Erik V. Norberg}
\lhead{Sorteringsalgoritmer}
\cfoot{\thepage}

\pagenumbering{arabic}

\lhead{Abstract}
\section*{Abstract}
\blindtext

\newpage
\lhead{Innehållsförteckning}
\tableofcontents

%\twocolumn
\newpage
\lhead{Introduktion}

\section{Inledning}

\subsection{Introduktion}
Du ska till ett bibliotek och hämta en bok. När du kommer fram till biblioteket börjar du kolla efter den. Men inga av böckerna verkar stå i någon ordning. Då inser du att alla böckerna i biblioteket inte är sorterade. Det är huller om buller. Du frågar då bibliotekarien varför det inte är sorterade. Hon svarar att det tar för lång tid för henne att sortera alla böcker eftersom det har så många, så hon har inte gjort det. Du, med ditt genialiska intellekt, kommer snabbt på att man kan skriva ett dataprogram som sorterar all böckerna snabbare än vad någon människa kan göra. Du utbrister då heureka! Sedan springer du hem och sätter dig framför din dator för att skriva dataprogrammet. Men du inser snabbt att det finns många, många, väldigt många olika sätt att sortera böckerna. Du kommer på ett flertal sätt man kan göra det men du vet inte vilken metod du ska använda. Du ville ju att programmet skulle vara snabbt så du bestämmer dig för att skriva alla metoder du har kommit på för att kunna se vilken som är snabbast. Detta är vad mitt gymnasiearbete kommer att handla om. Vilken metod (eller sorteringsalgoritm som det kallas) är mest effektiv när det kommer till sortering.\\
Inom datavetenskap är en sorteringsalgoritm en algoritm som sorterar element i en lista till en viss ordning. De mest vanliga ordningarna att sortera till är numerisk ordning eller lexikografisk ordning. Effektiv sortering är viktigt för att optimera effektiviteten av andra algoritmer (till exempel sök- och sammanslagningsalgoritmer) som kräver att dess givna data är i sorterad ordning. Sortering är också ofta användbart för kanonisering av data och för att producera mänsklig läsbar data. Mer formellt måste den sorterade datan från en sorteringsalgoritm uppfylla två villkor:\cite{1, 2}
\begin{enumerate}
    \item Den sorterade datan är i icke minskande ordning (varje element är inte mindre än föregående element efter den önskade ordningen);
    \item Resultatet är en permutation (en omordning som behåller alla original element) av den givna datan.
\end{enumerate}
Vidare lagras ingångsdata ofta i en matris, vilket tillåter slumpmässig åtkomst av dess element, snarare än en lista, som endast tillåter sekventiell åtkomst; även om många algoritmer kan tillämpas på vilken typ av data som helst efter lämplig modifiering.\\
Redan från början av datavetenskapen har sortering attraherat mycket forskning, kanske på grund av att det är ett problem som är lätt att konceptuellt förstå men är väldigt svårt att lösa. Blandet det första personerna som skrev sorteringsalgoritmer är Betty Holberton som skrev ENIAC och UNIVAC. En av det mest kända sorteringsalgoritmerna \textit{“Bubble sort”} skrevs redan så tidigt som 1956. Detta innebär att ämnet redan är väldigt väl undersökt. Så jag kommer inte kunna skriva någon ny sorteringsalgoritm men jag kommer kunna analysera det som redan finns. \cite{1} Mer exakt kommer jag analysera: \textit{Selection sort, Shellsort, Insertion Sort, Merge Sort, Quick Sort, Heap Sort, Bubble Sort, Comb sort} och \textit{Bidirectional Bubble Sort}.

\subsection{Syfte och metod}
Syftet med arbetet är att analyserna hastigheten av det nio olika algoritmerna som nämndes tidigare. Detta kommer redovisat genom att först visa hur man kan skriva algoritmerna i programmeringsspråket C\#. Det är viktigt att man förstår hur syntaxen i C\# fungerar så det kommer läggas stort fokus på hur syntaxen fungerar och vad den gör. Om man inte förstår programmet är det svårt för en att förstå resten av arbetet då C\# är grunden för resten av gymnasiearbetet. Följt av detta kommer matematiken bakom algoritmernas ordo (\textcolor{red}{se sida ???}) förklaras. Då matematiken bakom algoritmerna är komplex är det inte i fokus då det inte är lika viktigt för arbetets syfte. Detta innebär att det matematiken kommer förklaras men kommer inte gå in på en djupare nivå än vad som är nödvändigt.\\
Sorteringsalgoritmer i sin helhet öppnar upp många intressanta dörrar inom datavetenskapen. Men det är ett träsk av information och data som är omöjlig att analysera på en och samma gång. För att undvika det träsket kommer jag begränsa arbetet till enbart så kallade \textit{“Comparison sorting algorithms”} och inte \textit{“Non-Comparison sorting algorithms”}\footnote{Exempel på sådana algoritmer är: Pigeonhole sort, Bucket sort, MSD Radix sort, etc.} (eller andra former av sorteringsalgoritmer)\footnote{Exempel på sådana algoritmer är: Bead sort, Simple Pancake sort, Spaghetti sort, etc.}.\\
Sorteringsalgoritmer handlar inte bara om optimering utan också och om minneshantering inom RAM minnet. Särskilt är vissa sorteringsalgoritmer \textit{på plats}. Det innebär att det bara behöver $\mathcal{O}(1)$ eller $\mathcal{O}(\log{n})$ minne (beteckningen $\mathcal{O}$ förklaras mer \textcolor{red}{på sida ???}) utöver det objekt som sorteras och det behöver inte skapa temporära platser att spara datan i RAM minnet som andra algoritmer behöver göra. \cite{3} Dock så är frågan om minne inte viktigt för arbetet så jag kommer undvika frågan om minne. 

\subsection{Bakgrund}
\lhead{Bakgrund}
För att man ska kunna förstå algoritmerna måste man först förstå ett par fundamentala saker. Ordo, så att man förstå matematiken, C\# syntax, så man förstår programmen, och visa termer som kommer uppstå ett flertal gånger i arbetet.%\\\\
\subsubsection{Ordo}
Ordo (\textit{Big O Notation} på engelska och latin för \textit{ordning}) är ett begrepp inom matematiken och även datavetenskapen som används för att ge ett mått på hur beräkningsmässigt tung en funktion är. Detta betecknas med ett versalt $\mathcal{O}$. När en funktion beskrivs med ordo så beskrivs vanligtvist bara en övre gräns för funktionens tillväxthastighet. Associerat med $\mathcal{O}$ är ett par andra notationer som använder symbolerna $o$, $\Omega$, $\omega$ och $\Theta$ som beskriver andra gränser av asymptotisk tillväxthastighet. Dessa kommer vi gå igenom mer i detalj snart. Till exempel betecknar $\mathcal{O}(n^2)$ och $\mathcal{O}(\sqrt{n})$ något som växer lika fort som $n^2$ respektive $\sqrt{n}$ då $n$ ökar. Detta används särskilt inom datavetenskapen när man beskriver hastigheten av olika algoritmer, som sorteringsalgoritmer. \cite{4, 5}\\
Den formella definitionen lyder: Låt $f$ vara en reell eller komplex funktion och $g$ vara en reell funktion. Låt båda funktionerna vara definierade med någon begränsad delmängd av det positiva reella talen och $g(x)$ vara strikt positivt för stora $x$. Man skriver \cite{6}
\begin{equation*}
    f(x)=\mathcal{O}(g(x))\hspace{5mm}\text{när }x\rightarrow\infty
\end{equation*}
om absolutbeloppet av $f(x)$ är positiv konstant multiple av $g(x)$ för alla stora värden av $x$. Alltså är $f(x)=\mathcal{O}(g(x))$ om det existerar ett positivt reellt number $M$ och reellt numer $x_0$ så att
\begin{equation*}
    |f(x)|\leq Mg(x)\hspace{5mm}\text{för alla }x\leq x_0.
\end{equation*}
I många sammanhang lämnas antagandet att vi är intresserade av tillväxthastigheten när variabeln x går mot oändlighet, då skriver man mer enkelt
\begin{equation*}
   f(x)=\mathcal{O}(g(x)).
\end{equation*}
Ordo kan även användas för att beskriva betendet av $f$ nära ett reelt number $a$ (ofta $a=0$). Man skriver
\begin{equation*}
   f(x)=\mathcal{O}(g(x))\hspace{5mm}\text{när }x\rightarrow a
\end{equation*}
om det existerar ett positivt nummer $\delta$  och $M$ sådan att för alla $x$ med $0<|x-a|<\delta$
\begin{equation*}
   |f(x)|\leq Mg(x).
\end{equation*}
Eftersom $g(x)$ är valt att vara noll för värden på $x$ tillräckligt nära $a$, kan båda dessa definitioner förenas med användning av \textit{limit superior}:
\begin{equation*}
   f(x)=\mathcal{O}(g(x))\hspace{5mm}\text{när }x\rightarrow a
\end{equation*}
om
\begin{equation*}
   \limsup_{x\rightarrow a}\frac{|f(x)|}{g(x)}<\infty.
\end{equation*}
Det tidigare nämnda relaterade notationerna $o$, $\Omega$, $\omega$ och $\Theta$ kan man lätt förstå i tabellen under då det inte krävs några formella bevis för att förklara dem, eftersom det inte är lika viktiga för arbetet. 
\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|}
    \hline
    \rowcolor[HTML]{A4C2F4} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{A4C2F4}{\color[HTML]{000000} Notation}} & \multicolumn{1}{c|}{\cellcolor[HTML]{A4C2F4}{\color[HTML]{000000} I ord}} \\ \hline
    \rowcolor[HTML]{FFFFFF} 
    $f(n)\in\mathcal{O}(g(n))$                                                    & $f$ växer högst lika snabbt som $g$                                       \\ \hline
    \rowcolor[HTML]{F3F3F3} 
    $f(n)\in\Omega(g(n))$                                                         & $f$ växer minst lika snabbt som $g$                                       \\ \hline
    \rowcolor[HTML]{FFFFFF} 
    $f(n)\in\Theta(g(n))$                                                         & $f$ växer lika snabbt som $g$                                             \\ \hline
    \rowcolor[HTML]{F3F3F3} 
    $f(n)\in o(g(n))$                                                             & $f$ växer långsammare än $g$                                              \\ \hline
    \rowcolor[HTML]{FFFFFF} 
    $f(n)\in\omega(g(n))$                                                         & $f$ växer snabbare än $g$                                                 \\ \hline
    \end{tabular}
\end{table}
\newpage
\subsubsection{Fundamental C\#}
C\# (C-Sharp) är ett programmeringsspråk utvecklat av Microsoft som körs på .NET Framework. \cite{7} C\# är i första hand ett objektorienterat programspråk. Även kallad ett OOP\footnote{Från engelskans \textit{Object Oriented Programming}}. Det är varför detta arbete skrivs inom C\# då alla sorteringsalgoritmer kan skrivas som var sitt objekt. Ett objekt är en instans av samlad syntax som används för att utföra en given operation. Exempelvis kan ett objekt kallas på för att göra en viss beräkning eller för att sammanställa data. En objekt i C\# kan se ut såhär:
\begin{lstlisting}[style=mystyle, numbers=left]
 public void multiplyByTwo(int n)
 {
   return n * 2;
 }
\end{lstlisting}
Denna funktion tar in ett heltal, \lstinline{int n}, och ger tillbaka ett heltal dubbelt så stort som \lstinline{n}, \lstinline{return n * 2}.\\
En funktion i C\# måste inte bara behandla aritmetik. En funktion kan även behandla arrays (listor) vilket är väldigt användbart när man vill sortera. Exempelvis om vi har listan
\begin{lstlisting}[style=mystyle, numbers=none]
 int[] lista = {1, 2, 4, 3, 5};
\end{lstlisting}
och vi vill byta plats på fyran och femman för att få listan i storleksordning kan vi skriva en funktion som denna:
\begin{lstlisting}[style=mystyle, numbers=left]
 static void swap(int x, int y, int[] array)
 {
   int temp = array[x];
   array[x] = array[y];
   array[y] = temp;
 }
\end{lstlisting}
Den tar in två positioner \lstinline{x} och \lstinline{y} i en given lista \lstinline{array} och byter plats på dom. Den göra detta genom att spara heltalet på position \lstinline{x} i \lstinline{array} inuti en temporär variabel \lstinline{temp}. När \lstinline{x} är sparad i \lstinline{temp} överskrider funktionen \lstinline{x} med \lstinline{y}. Sist överskrider funktionen \lstinline{y} med \lstinline{temp}. Då har det två positionerna byt plats. Vi kallar på funktionen för att byta plats på fyran och trean i \lstinline{lista}:
\begin{lstlisting}[style=mystyle, numbers=none]
 swap(3, 4, lista);
\end{lstlisting}
och vi får att listan nu är 
\begin{lstlisting}[style=mystyle, numbers=none]
 [1, 2, 3, 4, 5]
\end{lstlisting}
Observera att \lstinline{swap} inte har en \lstinline{return}, såsom \lstinline{multiplyByTwo} har på rad $3$. Detta är då för att \lstinline{swap} inte ger tillbaka en ny lista. Den ändrar den givna arrayn utan att skapa en ny array medans \lstinline{multiplyByTwo} tar in ett heltal och ger tillbaka ett nytt heltal. Observera även att när vi kallar på \lstinline{swap} ger vi den $3$ och $4$ då det är positionerna av numrena vi vill byta plats på, inte för att det är $3$ och $4$ vi vill byta plats på. Om vi istället ville byta plats på $1$ och $3$ hade vi skrivit
\begin{lstlisting}[style=mystyle, numbers=none]
 swap(1, 4, lista);
\end{lstlisting}
Vilket hade gett
\begin{lstlisting}[style=mystyle, numbers=none]
 [3, 2, 4, 1, 5]
\end{lstlisting}
Funktion \lstinline{swap} kommer användas för varje sorteringsalgoritm som arbetet kommer analysera. Alltså varje gång en sorteringsalgoritm hänvisar till \lstinline{swap} kommer den köra koden som beskrivs ovan.

\subsubsection{Grundläggande algoritmer (\#1)}
Sorteringsalgoritmer kan vara väldigt komplexa och effektiva medans det är väldigt konceptuellt svåra att förstå. Docks så kan sorteringsalgoritmer vara väldigt simpla men med bekostnad av att vara mindre effektiva. Ett par simpla sorteringsalgoritmer vi kommer kolla på nu är \textit{Bubblesort}, \textit{Bidirectional Bubblesort} och, \textit{Shellsort}. Vi börjar med Bubblesort.\\
Bubblesort är bland det minst effektiva sorteringsalgoritmerna. Men den är ändå den mest kända sorteringsalgoritm eftersom den är sorteringsalgoritmernas \textit{“Hello World”}. Den är väldigt lätt att förstå både praktiskt och teoretiskt. Därför används den mest som ett pedagogiskt verktyg.\cite{8} Bubblesort fungerar genom att jämföra intilliggande element i en lista. Om elementen som jämförs ligger i fel ordning byter det plats så att det större elementet rör sig uppåt i listan. Denna process fortsätter tills det största elementet i listan är högst upp i listan. När detta är klart börjar algoritmen om men för det näst största elementet i listan. Detta repeteras till listan är sorterad. Låt oss säga att vi har en array 
\begin{lstlisting}[style=mystyle, numbers=none]
 int[] lista = {5, 1, 4, 2, 8};
\end{lstlisting}
som ska sorteras från minst till störst med Bubblesort. Det kommer bara ta tre iterationer för bubblesort att sortera arrayen (elementen skrivna i fetstil jämförs);\\\\
\textbf{Första iterationen:}
\begin{align*}
    [\textbf{5}, \textbf{1}, 4, 2, 8] &\rightarrow [\textbf{1}, \textbf{5}, 4, 2, 8]\\
    [1, \textbf{5}, \textbf{4}, 2, 8] &\rightarrow [1, \textbf{4}, \textbf{5}, 2, 8]\\
    [1, 4, \textbf{5}, \textbf{2}, 8] &\rightarrow [1, 4, \textbf{2}, \textbf{5}, 8]\\
    [1, 4, 2, \textbf{5}, \textbf{8}] &\rightarrow [1, 4, 2, \textbf{5}, \textbf{8}]
\end{align*}
\textbf{Andra iterationen:}
\begin{align*}
    [\textbf{1}, \textbf{4}, 2, 5, 8] &\rightarrow [\textbf{1}, \textbf{4}, 2, 5, 8]\\
    [1, \textbf{4}, \textbf{2}, 5, 8] &\rightarrow [1, \textbf{2}, \textbf{4}, 5, 8]\\
    [1, 2, \textbf{4}, \textbf{5}, 8] &\rightarrow [1, 2, \textbf{4}, \textbf{5}, 8]\\
    [1, 2, 4, \textbf{5}, \textbf{8}] &\rightarrow [1, 2, 4, \textbf{5}, \textbf{8}]
\end{align*}
Vid detta laget är arrayen redan sorterad men det vet inte algoritmen. Den måste iterera över hela arrayen utan att behöva byta några element för att veta att den är klar.\\\\
\textbf{Tredje iterationen:}
\begin{align*}
    [\textbf{1}, \textbf{2}, 4, 5, 8] &\rightarrow [\textbf{1}, \textbf{2}, 4, 5, 8]\\
    [1, \textbf{2}, \textbf{4}, 5, 8] &\rightarrow [1, \textbf{2}, \textbf{4}, 5, 8]\\
    [1, 2, \textbf{4}, \textbf{5}, 8] &\rightarrow [1, 2, \textbf{4}, \textbf{5}, 8]\\
    [1, 2, 4, \textbf{5}, \textbf{8}] &\rightarrow [1, 2, 4, \textbf{5}, \textbf{8}]
\end{align*}
Denna algoritm är lätt att implementera i C\# då den inte kräver många logiska operationer för att utföras:
\begin{lstlisting}[style=mystyle, numbers=left]
 static void bubbleSort(int[] array)
 {
   items = array.Length;
   for (int i = 0; i < items; i++)
   {
     for (int j = 0; j < items - 1; j++)
     {
       if (array[j] > array[i])
       {
         swap(i, j, array);
       }
     }
   }
 }
\end{lstlisting}
Nu kan vi kalla på \lstinline{bubbleSort} för att sortera \lstinline{lista}:
\begin{lstlisting}[style=mystyle, numbers=none]
 bubbleSort(lista);
\end{lstlisting}
Vilket sorterar \lstinline{lista} så att den nu är:
\begin{lstlisting}[style=mystyle, numbers=none]
 [1, 2, 4, 5, 8]
\end{lstlisting} 
Analysen av  Bubblesort är inte särskilt svår heller. Om vi har en array som är $n$ element lång så kommer Bubblesort behöva jämföra $(n-1)$ element första iteration. Andra iterationen kommer den behöva jämföra $(n-2)$ element. Tredje Iterationen kommer den behöva jämföra $(n-3)$ element och så vidare. Detta innebär att den totala mängden jämförelser  bubblesort kommer behöva göra är
\begin{equation*}
    (n-1) + (n-2) + \cdots + 2 + 1 = \sum\frac{n(n-1)}{2}
\end{equation*}
Vilket betyder att bubblesort har en tidskomplexitet av $\mathcal{O}(n^2)$.

\subsubsection{'Dela och erövra' algoritmer (\#2)}

\subsubsection{'Jämförelse på plats' algoritmer (\#3)}

\subsubsection{Övriga algoritmer (\#4)}

\section{Metod}

\section{Resultat}

\section{Diskussion och slutsatser}

\onecolumn
\newpage
\section{Källförteckning}
\printbibliography

\end{document}